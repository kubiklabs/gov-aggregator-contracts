{
  "contract_name": "cwd-core",
  "contract_version": "0.2.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "chain_list",
      "contract_registry",
      "description",
      "ica_helper_module_instantiate_info",
      "icq_helper_module_instantiate_info",
      "name",
      "proposal_modules_instantiate_info",
      "voting_registry_module_instantiate_info"
    ],
    "properties": {
      "chain_list": {
        "description": "Contains list of chain which this DAO will support and there respective values",
        "type": "array",
        "items": {
          "$ref": "#/definitions/ChainStakeInfo"
        }
      },
      "contract_registry": {
        "$ref": "#/definitions/Addr"
      },
      "dao_uri": {
        "description": "Implements the DAO Star standard: https://daostar.one/EIP",
        "type": [
          "string",
          "null"
        ]
      },
      "description": {
        "description": "A description of the core contract.",
        "type": "string"
      },
      "ica_helper_module_instantiate_info": {
        "description": "Instantiate information for the ica helper contract",
        "allOf": [
          {
            "$ref": "#/definitions/ModuleInstantiateInfo"
          }
        ]
      },
      "icq_helper_module_instantiate_info": {
        "$ref": "#/definitions/ModuleInstantiateInfo"
      },
      "initial_items": {
        "description": "Initial information for arbitrary contract addresses to be added to the items map. The key is the name of the item in the items map. The value is an enum that either uses an existing address or instantiates a new contract.",
        "type": [
          "array",
          "null"
        ],
        "items": {
          "$ref": "#/definitions/InitialItem"
        }
      },
      "name": {
        "description": "The name of the core contract.",
        "type": "string"
      },
      "proposal_modules_instantiate_info": {
        "description": "Instantiate information for the core contract's proposal modules.",
        "type": "array",
        "items": {
          "$ref": "#/definitions/ModuleInstantiateInfo"
        }
      },
      "voting_registry_module_instantiate_info": {
        "description": "Instantiate information for the core contract's voting power module.",
        "allOf": [
          {
            "$ref": "#/definitions/ModuleInstantiateInfo"
          }
        ]
      }
    },
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "Admin": {
        "description": "Information about the CosmWasm level admin of a contract. Used in conjunction with `ModuleInstantiateInfo` to instantiate modules.",
        "oneOf": [
          {
            "description": "Set the admin to a specified address.",
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "required": [
                  "addr"
                ],
                "properties": {
                  "addr": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets the admin as the core module address.",
            "type": "object",
            "required": [
              "core_module"
            ],
            "properties": {
              "core_module": {
                "type": "object"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "ChainStakeInfo": {
        "description": "For receiving chain and their stake value.",
        "type": "object",
        "required": [
          "chain_id",
          "connection_id",
          "stake"
        ],
        "properties": {
          "chain_id": {
            "description": "chain-id of the chain which got registered in the DAO.",
            "type": "string"
          },
          "connection_id": {
            "description": "connection-id of the chain which got registered in the DAO.",
            "type": "string"
          },
          "stake": {
            "description": "stake is the value of chain-id which hold in the list of chain",
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          }
        }
      },
      "InitialItem": {
        "description": "Information about an item to be stored in the items list.",
        "type": "object",
        "required": [
          "key",
          "value"
        ],
        "properties": {
          "key": {
            "description": "The name of the item.",
            "type": "string"
          },
          "value": {
            "description": "The value the item will have at instantiation time.",
            "type": "string"
          }
        }
      },
      "ModuleInstantiateInfo": {
        "description": "Information needed to instantiate a module.",
        "type": "object",
        "required": [
          "code_id",
          "label",
          "msg"
        ],
        "properties": {
          "admin": {
            "description": "CosmWasm level admin of the instantiated contract. See: <https://docs.cosmwasm.com/docs/1.0/smart-contracts/migration>",
            "anyOf": [
              {
                "$ref": "#/definitions/Admin"
              },
              {
                "type": "null"
              }
            ]
          },
          "code_id": {
            "description": "Code ID of the contract to be instantiated.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "label": {
            "description": "Label for the instantiated contract.",
            "type": "string"
          },
          "msg": {
            "description": "Instantiate message to be used to create the contract.",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        }
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Callable by proposal modules. The DAO will execute the messages in the hook in order.",
        "type": "object",
        "required": [
          "execute_proposal_hook"
        ],
        "properties": {
          "execute_proposal_hook": {
            "type": "object",
            "required": [
              "msgs"
            ],
            "properties": {
              "msgs": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/WasmMsg"
                }
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Pauses the DAO for a set duration. When paused the DAO is unable to execute proposals",
        "type": "object",
        "required": [
          "pause"
        ],
        "properties": {
          "pause": {
            "type": "object",
            "required": [
              "duration"
            ],
            "properties": {
              "duration": {
                "$ref": "#/definitions/Duration"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Removes an item from the governance contract's item map.",
        "type": "object",
        "required": [
          "remove_item"
        ],
        "properties": {
          "remove_item": {
            "type": "object",
            "required": [
              "key"
            ],
            "properties": {
              "key": {
                "type": "string"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Adds an item to the governance contract's item map. If the item already exists the existing value is overriden. If the item does not exist a new item is added.",
        "type": "object",
        "required": [
          "set_item"
        ],
        "properties": {
          "set_item": {
            "type": "object",
            "required": [
              "addr",
              "key"
            ],
            "properties": {
              "addr": {
                "type": "string"
              },
              "key": {
                "type": "string"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Callable by the core contract. Replaces the current governance contract config with the provided config.",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "required": [
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/definitions/Config"
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the governance contract's governance modules. Module instantiate info in `to_add` is used to create new modules and install them.",
        "type": "object",
        "required": [
          "update_proposal_modules"
        ],
        "properties": {
          "update_proposal_modules": {
            "type": "object",
            "required": [
              "to_add",
              "to_disable"
            ],
            "properties": {
              "to_add": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ModuleInstantiateInfo"
                }
              },
              "to_disable": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Callable by the core contract. Replaces the current voting module with a new one instantiated by the governance contract.",
        "type": "object",
        "required": [
          "update_voting_module"
        ],
        "properties": {
          "update_voting_module": {
            "type": "object",
            "required": [
              "module"
            ],
            "properties": {
              "module": {
                "$ref": "#/definitions/ModuleInstantiateInfo"
              }
            }
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Admin": {
        "description": "Information about the CosmWasm level admin of a contract. Used in conjunction with `ModuleInstantiateInfo` to instantiate modules.",
        "oneOf": [
          {
            "description": "Set the admin to a specified address.",
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "object",
                "required": [
                  "addr"
                ],
                "properties": {
                  "addr": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets the admin as the core module address.",
            "type": "object",
            "required": [
              "core_module"
            ],
            "properties": {
              "core_module": {
                "type": "object"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Config": {
        "description": "Top level config type for core module.",
        "type": "object",
        "required": [
          "description",
          "name"
        ],
        "properties": {
          "dao_uri": {
            "description": "The URI for the DAO as defined by the DAOstar standard https://daostar.one/EIP",
            "type": [
              "string",
              "null"
            ]
          },
          "description": {
            "description": "A description of the contract.",
            "type": "string"
          },
          "name": {
            "description": "The name of the contract.",
            "type": "string"
          }
        }
      },
      "Duration": {
        "description": "Duration is a delta of time. You can add it to a BlockInfo or Expiration to move that further in the future. Note that an height-based Duration and a time-based Expiration cannot be combined",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "height"
            ],
            "properties": {
              "height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Time in seconds",
            "type": "object",
            "required": [
              "time"
            ],
            "properties": {
              "time": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ModuleInstantiateInfo": {
        "description": "Information needed to instantiate a module.",
        "type": "object",
        "required": [
          "code_id",
          "label",
          "msg"
        ],
        "properties": {
          "admin": {
            "description": "CosmWasm level admin of the instantiated contract. See: <https://docs.cosmwasm.com/docs/1.0/smart-contracts/migration>",
            "anyOf": [
              {
                "$ref": "#/definitions/Admin"
              },
              {
                "type": "null"
              }
            ]
          },
          "code_id": {
            "description": "Code ID of the contract to be instantiated.",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "label": {
            "description": "Label for the instantiated contract.",
            "type": "string"
          },
          "msg": {
            "description": "Instantiate message to be used to create the contract.",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "WasmMsg": {
        "description": "The message types of the wasm module.\n\nSee https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto",
        "oneOf": [
          {
            "description": "Dispatches a call to another contract at a known address (with known ABI).\n\nThis is translated to a [MsgExecuteContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L68-L78). `sender` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "execute"
            ],
            "properties": {
              "execute": {
                "type": "object",
                "required": [
                  "contract_addr",
                  "funds",
                  "msg"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  },
                  "funds": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "msg": {
                    "description": "msg is the json-encoded ExecuteMsg struct (as raw Binary)",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Instantiates a new contracts from previously uploaded Wasm code.\n\nThe contract address is non-predictable. But it is guaranteed that when emitting the same Instantiate message multiple times, multiple instances on different addresses will be generated. See also Instantiate2.\n\nThis is translated to a [MsgInstantiateContract](https://github.com/CosmWasm/wasmd/blob/v0.29.2/proto/cosmwasm/wasm/v1/tx.proto#L53-L71). `sender` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "instantiate"
            ],
            "properties": {
              "instantiate": {
                "type": "object",
                "required": [
                  "code_id",
                  "funds",
                  "label",
                  "msg"
                ],
                "properties": {
                  "admin": {
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "code_id": {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  },
                  "funds": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "label": {
                    "description": "A human-readable label for the contract.\n\nValid values should: - not be empty - not be bigger than 128 bytes (or some chain-specific limit) - not start / end with whitespace",
                    "type": "string"
                  },
                  "msg": {
                    "description": "msg is the JSON-encoded InstantiateMsg struct (as raw Binary)",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to customize behavior.\n\nOnly the contract admin (as defined in wasmd), if any, is able to make this call.\n\nThis is translated to a [MsgMigrateContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L86-L96). `sender` is automatically filled with the current contract's address.",
            "type": "object",
            "required": [
              "migrate"
            ],
            "properties": {
              "migrate": {
                "type": "object",
                "required": [
                  "contract_addr",
                  "msg",
                  "new_code_id"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  },
                  "msg": {
                    "description": "msg is the json-encoded MigrateMsg struct that will be passed to the new code",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Binary"
                      }
                    ]
                  },
                  "new_code_id": {
                    "description": "the code_id of the new logic to place in the given contract",
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sets a new admin (for migrate) on the given contract. Fails if this contract is not currently admin of the target contract.",
            "type": "object",
            "required": [
              "update_admin"
            ],
            "properties": {
              "update_admin": {
                "type": "object",
                "required": [
                  "admin",
                  "contract_addr"
                ],
                "properties": {
                  "admin": {
                    "type": "string"
                  },
                  "contract_addr": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Clears the admin on the given contract, so no more migration possible. Fails if this contract is not currently admin of the target contract.",
            "type": "object",
            "required": [
              "clear_admin"
            ],
            "properties": {
              "clear_admin": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  }
                }
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Gets the contract's config. Returns Config.",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Dumps all of the core contract's state in a single query. Useful for frontends as performance for queries is more limited by network times than compute times. Returns `DumpStateResponse`.",
        "type": "object",
        "required": [
          "dump_state"
        ],
        "properties": {
          "dump_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the address associated with an item key.",
        "type": "object",
        "required": [
          "get_item"
        ],
        "properties": {
          "get_item": {
            "type": "object",
            "required": [
              "key"
            ],
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Lists all of the items associted with the contract. For example, given the items `{ \"group\": \"foo\", \"subdao\": \"bar\"}` this query would return `[(\"group\", \"foo\"), (\"subdao\", \"bar\")]`.",
        "type": "object",
        "required": [
          "list_items"
        ],
        "properties": {
          "list_items": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets all proposal modules associated with the contract. Returns Vec<ProposalModule>.",
        "type": "object",
        "required": [
          "proposal_modules"
        ],
        "properties": {
          "proposal_modules": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "list_chain_voting_power_at_height"
        ],
        "properties": {
          "list_chain_voting_power_at_height": {
            "type": "object",
            "required": [
              "chains"
            ],
            "properties": {
              "chains": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "aggregate_voting_power_all_chain"
        ],
        "properties": {
          "aggregate_voting_power_all_chain": {
            "type": "object",
            "required": [
              "address",
              "chains"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "chains": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the active proposal modules associated with the contract. Returns Vec<ProposalModule>.",
        "type": "object",
        "required": [
          "active_proposal_modules"
        ],
        "properties": {
          "active_proposal_modules": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns information about if the contract is currently paused.",
        "type": "object",
        "required": [
          "pause_info"
        ],
        "properties": {
          "pause_info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the contract's voting module. Returns Addr.",
        "type": "object",
        "required": [
          "voting_module"
        ],
        "properties": {
          "voting_module": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns all SubDAOs with their charters in a vec start_after is bound exclusive and asks for a string address Implements the DAO Star standard: https://daostar.one/EIP",
        "type": "object",
        "required": [
          "dao_u_r_i"
        ],
        "properties": {
          "dao_u_r_i": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "voting_power_at_height"
        ],
        "properties": {
          "voting_power_at_height": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "height": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "total_power_at_height"
        ],
        "properties": {
          "total_power_at_height": {
            "type": "object",
            "properties": {
              "height": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "info"
        ],
        "properties": {
          "info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "type": "object"
  },
  "sudo": null,
  "responses": {
    "active_proposal_modules": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_ProposalModule",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ProposalModule"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "ProposalModule": {
          "description": "Top level type describing a proposal module.",
          "type": "object",
          "required": [
            "address",
            "prefix",
            "status"
          ],
          "properties": {
            "address": {
              "description": "The address of the proposal module.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "prefix": {
              "description": "The URL prefix of this proposal module as derived from the module ID. Prefixes are mapped to letters, e.g. 0 is 'A', and 26 is 'AA'.",
              "type": "string"
            },
            "status": {
              "description": "The status of the proposal module, e.g. 'Active' or 'Disabled.'",
              "allOf": [
                {
                  "$ref": "#/definitions/ProposalModuleStatus"
                }
              ]
            }
          }
        },
        "ProposalModuleStatus": {
          "description": "The status of a proposal module.",
          "type": "string",
          "enum": [
            "Enabled",
            "Disabled"
          ]
        }
      }
    },
    "aggregate_voting_power_all_chain": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TotalPowerAtHeightResponse",
      "type": "object",
      "required": [
        "height",
        "power"
      ],
      "properties": {
        "height": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "power": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "description": "Top level config type for core module.",
      "type": "object",
      "required": [
        "description",
        "name"
      ],
      "properties": {
        "dao_uri": {
          "description": "The URI for the DAO as defined by the DAOstar standard https://daostar.one/EIP",
          "type": [
            "string",
            "null"
          ]
        },
        "description": {
          "description": "A description of the contract.",
          "type": "string"
        },
        "name": {
          "description": "The name of the contract.",
          "type": "string"
        }
      }
    },
    "dao_u_r_i": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_String",
      "type": [
        "string",
        "null"
      ]
    },
    "dump_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DumpStateResponse",
      "description": "Relevant state for the governance module. Returned by the `DumpState` query.",
      "type": "object",
      "required": [
        "active_proposal_module_count",
        "config",
        "ica_helper",
        "pause_info",
        "proposal_modules",
        "total_proposal_module_count",
        "version"
      ],
      "properties": {
        "active_proposal_module_count": {
          "description": "The number of active proposal modules.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "config": {
          "description": "The governance contract's config.",
          "allOf": [
            {
              "$ref": "#/definitions/Config"
            }
          ]
        },
        "ica_helper": {
          "description": "The voting module associated with the governance contract. The ICA helper module associated with the governance contract.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "pause_info": {
          "$ref": "#/definitions/PauseInfoResponse"
        },
        "proposal_modules": {
          "description": "The governance modules associated with the governance contract.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ProposalModule"
          }
        },
        "total_proposal_module_count": {
          "description": "The total number of proposal modules.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "version": {
          "description": "The governance contract's version.",
          "allOf": [
            {
              "$ref": "#/definitions/ContractVersion"
            }
          ]
        }
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Config": {
          "description": "Top level config type for core module.",
          "type": "object",
          "required": [
            "description",
            "name"
          ],
          "properties": {
            "dao_uri": {
              "description": "The URI for the DAO as defined by the DAOstar standard https://daostar.one/EIP",
              "type": [
                "string",
                "null"
              ]
            },
            "description": {
              "description": "A description of the contract.",
              "type": "string"
            },
            "name": {
              "description": "The name of the contract.",
              "type": "string"
            }
          }
        },
        "ContractVersion": {
          "type": "object",
          "required": [
            "contract",
            "version"
          ],
          "properties": {
            "contract": {
              "description": "contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing",
              "type": "string"
            },
            "version": {
              "description": "version is any string that this implementation knows. It may be simple counter \"1\", \"2\". or semantic version on release tags \"v0.7.0\", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PauseInfoResponse": {
          "description": "Information about if the contract is currently paused.",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "Paused"
              ],
              "properties": {
                "Paused": {
                  "type": "object",
                  "required": [
                    "expiration"
                  ],
                  "properties": {
                    "expiration": {
                      "$ref": "#/definitions/Expiration"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "Unpaused"
              ],
              "properties": {
                "Unpaused": {
                  "type": "object"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "ProposalModule": {
          "description": "Top level type describing a proposal module.",
          "type": "object",
          "required": [
            "address",
            "prefix",
            "status"
          ],
          "properties": {
            "address": {
              "description": "The address of the proposal module.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "prefix": {
              "description": "The URL prefix of this proposal module as derived from the module ID. Prefixes are mapped to letters, e.g. 0 is 'A', and 26 is 'AA'.",
              "type": "string"
            },
            "status": {
              "description": "The status of the proposal module, e.g. 'Active' or 'Disabled.'",
              "allOf": [
                {
                  "$ref": "#/definitions/ProposalModuleStatus"
                }
              ]
            }
          }
        },
        "ProposalModuleStatus": {
          "description": "The status of a proposal module.",
          "type": "string",
          "enum": [
            "Enabled",
            "Disabled"
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_item": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GetItemResponse",
      "description": "Returned by the `GetItem` query.",
      "type": "object",
      "properties": {
        "item": {
          "description": "`None` if no item with the provided key was found, `Some` otherwise.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "InfoResponse",
      "type": "object",
      "required": [
        "info"
      ],
      "properties": {
        "info": {
          "$ref": "#/definitions/ContractVersion"
        }
      },
      "definitions": {
        "ContractVersion": {
          "type": "object",
          "required": [
            "contract",
            "version"
          ],
          "properties": {
            "contract": {
              "description": "contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing",
              "type": "string"
            },
            "version": {
              "description": "version is any string that this implementation knows. It may be simple counter \"1\", \"2\". or semantic version on release tags \"v0.7.0\", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "list_chain_voting_power_at_height": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TotalPowerAtHeightResponse",
      "type": "object",
      "required": [
        "height",
        "power"
      ],
      "properties": {
        "height": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "power": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "list_items": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_Tuple_of_String_and_String",
      "type": "array",
      "items": {
        "type": "array",
        "items": [
          {
            "type": "string"
          },
          {
            "type": "string"
          }
        ],
        "maxItems": 2,
        "minItems": 2
      }
    },
    "pause_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PauseInfoResponse",
      "description": "Information about if the contract is currently paused.",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "Paused"
          ],
          "properties": {
            "Paused": {
              "type": "object",
              "required": [
                "expiration"
              ],
              "properties": {
                "expiration": {
                  "$ref": "#/definitions/Expiration"
                }
              }
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "Unpaused"
          ],
          "properties": {
            "Unpaused": {
              "type": "object"
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "proposal_modules": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_ProposalModule",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ProposalModule"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "ProposalModule": {
          "description": "Top level type describing a proposal module.",
          "type": "object",
          "required": [
            "address",
            "prefix",
            "status"
          ],
          "properties": {
            "address": {
              "description": "The address of the proposal module.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "prefix": {
              "description": "The URL prefix of this proposal module as derived from the module ID. Prefixes are mapped to letters, e.g. 0 is 'A', and 26 is 'AA'.",
              "type": "string"
            },
            "status": {
              "description": "The status of the proposal module, e.g. 'Active' or 'Disabled.'",
              "allOf": [
                {
                  "$ref": "#/definitions/ProposalModuleStatus"
                }
              ]
            }
          }
        },
        "ProposalModuleStatus": {
          "description": "The status of a proposal module.",
          "type": "string",
          "enum": [
            "Enabled",
            "Disabled"
          ]
        }
      }
    },
    "total_power_at_height": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TotalPowerAtHeightResponse",
      "type": "object",
      "required": [
        "height",
        "power"
      ],
      "properties": {
        "height": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "power": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "voting_module": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Addr",
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "voting_power_at_height": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VotingPowerAtHeightResponse",
      "type": "object",
      "required": [
        "height",
        "power"
      ],
      "properties": {
        "height": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "power": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
